Big Picture: How Youâ€™ll Make It â€œREALâ€

For every feature (Products, Customers, Subscriptions, Orders), the pattern is:

Database â€“ Table + schema (Drizzle)

Backend API â€“ Express routes + controllers + validation

Auth & Permissions â€“ Only Admin can call admin APIs

Frontend Admin UI â€“ Replace mock data with API calls

Testing â€“ Try full flow in browser + DB

Weâ€™ll start with Step-1: Product Management, because:

No products â†’ no subscriptions â†’ no orders

STEP 1 â€“ âœ… Make Product Management Fully Working
1.1 â€“ Define / confirm products table in DB

If you donâ€™t already have it, you want something like:

Fields you need:

id â€“ primary key

name â€“ string

price â€“ number (integer in paise or decimal)

unit â€“ e.g. "500ml", "200g"

category â€“ e.g. "milk", "paneer"

stock â€“ integer

image_url â€“ string (for product image path)

is_active â€“ boolean (soft-disable a product)

In Drizzle schema (example):

// db/schema/products.ts
import { pgTable, serial, varchar, integer, boolean, numeric } from "drizzle-orm/pg-core";

export const products = pgTable("products", {
  id: serial("id").primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  price: numeric("price", { precision: 10, scale: 2 }).notNull(),
  unit: varchar("unit", { length: 50 }).notNull(),
  category: varchar("category", { length: 100 }).notNull(),
  stock: integer("stock").notNull().default(0),
  imageUrl: varchar("image_url", { length: 500 }),
  isActive: boolean("is_active").notNull().default(true),
});


Run your migration (however youâ€™ve set that up) so the table exists.

1.2 â€“ Backend: Create Admin Product APIs

You want these routes:

GET /admin/products â†’ list all products

GET /admin/products/:id â†’ single product

POST /admin/products â†’ create

PUT /admin/products/:id â†’ update

DELETE /admin/products/:id â†’ delete

a) Admin auth middleware

Make sure only admins can access:

// middleware/isAdmin.ts
import { Request, Response, NextFunction } from "express";

export function requireAdmin(req: Request, res: Response, next: NextFunction) {
  const user = (req as any).user; // from your auth middleware
  if (!user || user.role !== "admin") {
    return res.status(403).json({ message: "Admin access required" });
  }
  next();
}

b) Product controller
// routes/adminProducts.ts
import { Router } from "express";
import { db } from "../db"; // your drizzle db instance
import { products } from "../db/schema/products";
import { eq } from "drizzle-orm";
import { requireAdmin } from "../middleware/isAdmin";

const router = Router();

// GET /admin/products
router.get("/", requireAdmin, async (req, res) => {
  const rows = await db.select().from(products).orderBy(products.id);
  res.json(rows);
});

// GET /admin/products/:id
router.get("/:id", requireAdmin, async (req, res) => {
  const id = Number(req.params.id);
  const rows = await db.select().from(products).where(eq(products.id, id));
  if (!rows[0]) return res.status(404).json({ message: "Not found" });
  res.json(rows[0]);
});

// POST /admin/products
router.post("/", requireAdmin, async (req, res) => {
  const { name, price, unit, category, stock, imageUrl } = req.body;

  if (!name || !price || !unit || !category) {
    return res.status(400).json({ message: "Missing required fields" });
  }

  const [inserted] = await db
    .insert(products)
    .values({ name, price, unit, category, stock: stock ?? 0, imageUrl })
    .returning();

  res.status(201).json(inserted);
});

// PUT /admin/products/:id
router.put("/:id", requireAdmin, async (req, res) => {
  const id = Number(req.params.id);
  const { name, price, unit, category, stock, imageUrl, isActive } = req.body;

  const [updated] = await db
    .update(products)
    .set({ name, price, unit, category, stock, imageUrl, isActive })
    .where(eq(products.id, id))
    .returning();

  if (!updated) return res.status(404).json({ message: "Not found" });
  res.json(updated);
});

// DELETE /admin/products/:id
router.delete("/:id", requireAdmin, async (req, res) => {
  const id = Number(req.params.id);
  await db.delete(products).where(eq(products.id, id));
  res.status(204).send();
});

export default router;


Mount this in your main server:

// server.ts or app.ts
import adminProductsRouter from "./routes/adminProducts";

app.use("/admin/products", adminProductsRouter);


Now your backend for products is REAL.

1.3 â€“ Frontend: Connect Admin UI to API

You already have an Admin Products page with mock data.
We replace that with real calls using fetch or React Query.

Example using React Query:

// hooks/useAdminProducts.ts
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";

export function useAdminProducts() {
  const queryClient = useQueryClient();

  const productsQuery = useQuery({
    queryKey: ["admin-products"],
    queryFn: async () => {
      const res = await fetch("/admin/products", { credentials: "include" });
      if (!res.ok) throw new Error("Failed to fetch products");
      return res.json();
    },
  });

  const createProduct = useMutation({
    mutationFn: async (data: any) => {
      const res = await fetch("/admin/products", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify(data),
      });
      if (!res.ok) throw new Error("Failed to create product");
      return res.json();
    },
    onSuccess: () => queryClient.invalidateQueries(["admin-products"]),
  });

  const updateProduct = useMutation({
    mutationFn: async ({ id, data }: { id: number; data: any }) => {
      const res = await fetch(`/admin/products/${id}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify(data),
      });
      if (!res.ok) throw new Error("Failed to update product");
      return res.json();
    },
    onSuccess: () => queryClient.invalidateQueries(["admin-products"]),
  });

  const deleteProduct = useMutation({
    mutationFn: async (id: number) => {
      const res = await fetch(`/admin/products/${id}`, {
        method: "DELETE",
        credentials: "include",
      });
      if (!res.ok) throw new Error("Failed to delete product");
      return true;
    },
    onSuccess: () => queryClient.invalidateQueries(["admin-products"]),
  });

  return { productsQuery, createProduct, updateProduct, deleteProduct };
}


Then in your Admin Products page:

// AdminProductsPage.tsx
import { useAdminProducts } from "../hooks/useAdminProducts";

export function AdminProductsPage() {
  const { productsQuery, createProduct, updateProduct, deleteProduct } =
    useAdminProducts();

  if (productsQuery.isLoading) return <div>Loading...</div>;
  if (productsQuery.error) return <div>Error loading products</div>;

  const products = productsQuery.data;

  return (
    <div>
      <h1 className="text-2xl font-bold mb-4">Products</h1>

      {/* TABLE */}
      <table className="w-full border text-sm">
        <thead>
          <tr className="bg-gray-100">
            <th>Name</th>
            <th>Price</th>
            <th>Unit</th>
            <th>Category</th>
            <th>Stock</th>
            <th />
          </tr>
        </thead>
        <tbody>
          {products.map((p: any) => (
            <tr key={p.id} className="border-b">
              <td>{p.name}</td>
              <td>â‚¹{p.price}</td>
              <td>{p.unit}</td>
              <td>{p.category}</td>
              <td>{p.stock}</td>
              <td>
                <button
                  onClick={() =>
                    deleteProduct.mutate(p.id)
                  }
                  className="text-red-600"
                >
                  Delete
                </button>
                {/* Also add Edit button + modal/form */}
              </td>
            </tr>
          ))}
        </tbody>
      </table>

      {/* Add product form can use createProduct.mutate() */}
    </div>
  );
}


Once this is done:

Adding a product in Admin UI â†’ saves in DB

Deleting / editing â†’ updates DB

Customer Shop page â†’ can read real products from same table

ðŸŽ‰ Product Management is now dynamic + working.

STEP 2 â€“ ðŸ‘¥ Customers Management

After Products, do Customers.

2.1 â€“ Use existing users table

You likely already have users with fields like:

id, name, phone, email

role (customer/admin/vendor/delivery)

created_at, etc.

2.2 â€“ Backend: Admin Customers API

GET /admin/customers â†’ all users where role = "customer"

// routes/adminCustomers.ts
router.get("/", requireAdmin, async (req, res) => {
  const rows = await db
    .select()
    .from(users)
    .where(eq(users.role, "customer"));
  res.json(rows);
});

2.3 â€“ Frontend: Customers Page

Table:

| Name | Phone | Email | Total Orders | Subscription Status |

You can later compute totalOrders and subscriptionStatus from orders and subscriptions tables.

STEP 3 â€“ ðŸ¥› Milk Subscriptions Control

Once products & customers are real, move to subscriptions.

3.1 â€“ DB: subscriptions table

Fields:

id

user_id

product_id (usually milk)

quantity_per_day

frequency (daily/weekly/monthly)

delivery_slot

next_delivery_date

status (active/paused/cancelled)

3.2 â€“ Admin APIs:

GET /admin/subscriptions

PUT /admin/subscriptions/:id (pause / change quantity / change slot)

Admin subscriptions page: filter by customer, product, status.

STEP 4 â€“ ðŸ“¦ Orders Management

Now you allow one-time orders + subscription deliveries.

4.1 â€“ DB: orders + order_items

You already have this in your design. Make sure:

orders has: id, user_id, total_amount, status, payment_method, created_at, etc.

order_items links each product + quantity.

4.2 â€“ Admin APIs:

GET /admin/orders

GET /admin/orders/:id

PUT /admin/orders/:id â†’ update status

(Later) PUT /admin/orders/:id/assign â†’ assign delivery partner

ðŸ“Œ Recommended Implementation Order (For You Now)

To keep it realistic and not overwhelming, Iâ€™d suggest this sequence:

âœ… Phase 1 â€“ This Week

Products

 DB table confirmed

 Drizzle schema

 /admin/products CRUD routes

 Admin Products UI uses real data (no mocks)

 Customer Shop page reads from same products API

â¬œ Phase 2 â€“ Next

Customers

 GET /admin/customers

 Customers page in Admin

Orders

 Orders DB confirmed

 GET /admin/orders + basic list in Admin

Subscriptions

 subscriptions DB

 GET /admin/subscriptions

 Basic control (pause/resume)